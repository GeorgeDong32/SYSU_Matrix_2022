# 21程设II-周7-课后-1

# 综述

#### 何为队列

**队列**（Queue）是一种**先进先出**（First in first out, FIFO）的线性数据结构。从本质上来讲，队列是一种特殊的数组——它只能在数组的其中一端（队头）删除元素，并且只能在另一端（队尾）插入元素。这和我们平时排队买东西的情况非常相似——我们永远从最后面加入队伍，从最前面离开队伍（当然，排除出现插队的闸种、中途上撤硕这些特殊情况）。
队列的经典操作包括**入队**、**出队**、**获取队列大小**、**获取队头元素**、**获取队尾元素**等。在本题中，我们会实现前3个经典的操作（即入队、出队、获取队列大小）。并且和传统的队列结构不同的是，本题支持使用下标索引"[ ]"来实现对队列中元素的随机访问。

#### 队列的实现

队列的实现方式有很多种，**循环数组**是其中一种非常简单、经典的实现方式，它采用数组来存储队列中的数据，而使用两个索引值front和back来模拟队头和队尾。所谓循环数组，就是指当填充数据的位置超过数组的最大索引值时，改为在数组的头部进行数据填充，**在非循环的线性物理结构数组上，维护其循环的假象**。
**![用循环数组模拟的队列](https://media.geeksforgeeks.org/wp-content/uploads/Circular-queue.png)本题会基于循环数组来实现这个队列。可能有同学在此前了解过队列数据结构的一些基本操作（如入队push()、出队pop()等）。在本题的实现中，请用运算符"+="来实现数据的入队操作，请用运算符"--"来实现出队操作。
***提示：本题中队列的最大长度不超过100，这也就意味着同时最多有100个元素能够被存储在队列内。***

# 实现细节

**看完上面的综述，依然不知道队列如何实现？没有关系！请详细阅读下面的细节实现描述，它会帮助大家从零开始实现这个OperatorLinkedQueue。**

#### 私有成员

**int arr[]**：用于存储队列中的数据。本题中队列最大长度为100，因此可以自然而然想到要为arr分配一个大小为至少100个int的动态空间。
**int front**：队头所在索引。队列中所有的删除（出队）操作都是在数组中的front位置进行的。**int back：队尾所在索引。队列中所有的插入（入队）操作都是在数组中的back位置进行的。
**int size**：队列当前已容纳元素数量。由于在循环数组实现的队列中，无论在队空状态下还是队满状态下，都满足front == back。所以我们可以额外使用一个size变量，来更方便地获取目前队列中容纳的数据量，并判断队列是否为空/为满。

#### 公有成员

**OperatorLinkedQueue()**：默认构造函数，为arr新分配能容纳100个int的空间。
**OperatorLinkedQueue(const OperatorLinkedQueue&)**：拷贝构造函数，注意arr指针的复制操作（懂得都懂）。
**~OperatorLinkedQueue()**：析构函数。很简单，只是要释放arr动态申请的内存空间。**
**int GetSize() const**：返回当前队列的容纳数据量（size）。
**int & operator[] (const int &index)**：按索引index访问队列中的元素，返回索引表示可对队列中元素进行修改。注意，这里的index是逻辑上元素相对于队头的位置（比如index=2，就是队伍中排在第3个的元素，而不是arr[2]）。
**int operator[] (const int &index) const**：和上面一样，不过这里返回的是队列中的元素的拷贝。其实方法的实现是完全一样的，只是这里去掉了'&'引用符号，并添加了const关键字而已。

**OperatorLinkedQueue operator= (const OperatorLinkedQueue&)**：重载赋值运算符，可以直接调用拷贝构造函数（只要你拷贝构造函数传参时加了const关键字）。
**OperatorLinkedQueue operator+= (const int &)**：在队伍的最后端添加一个元素，模拟入队操作。如果此时队伍元素已满，则不进行任何操作。
**OperatorLinkedQueue operator-- ()**：自减运算符，在队伍的最前端删除一个元素，模拟出队操作。如果此时队伍元素为空，则不进行任何操作。
**OperatorLinkedQueue operator-- (int)**：自减运算符，和上面的类似，唯一区别在于上面的是`--OperatorLinkedQueue`，而这里是`OperatorLinkedQueue--`。大家可以回忆一下--运算符放在前面和后面的区别。
**friend ostream& operator << (ostream &, const OperatorLinkedList &)**：重载输出运算符。我们希望在输出的时候，用"->"来依次连接每个元素的输出（比如"1->3->5->7"），最后一个元素后面不需要添加"->"。

# [样例输入]

10
3 5 7 9 1 4 6 8 10 2

# [样例输出]

3->5->7->9->1->4->6->8->10->2
3->5->7->9->1->4->6->8->10->2
7->9->1->4->6->8->10->2
3->5->7->9->1->4->6->8->10->2

